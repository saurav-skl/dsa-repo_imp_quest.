1. Maximum Depth of Binary Tree

class Solution {
public:
    int maxDepth(TreeNode* root) {
       if(!root) 
           return 0;
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return 1+max(left,right);
    }
};

2. Invert Binary tree 

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root)
            return NULL;
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        root->left = right;
        root->right = left;
        return root;
    }
};


3. Symmetric Tree

class Solution {
    bool symmetricTree(TreeNode* left, TreeNode* right){
        if(!left and !right)
            return true;
        if((left and !right) or (!left and right))
            return false;
        return left->val==right->val and symmetricTree(left->left,right->right) and symmetricTree(left->right,right->left);
    }
public:
    bool isSymmetric(TreeNode* root) {
        if(!root)
            return NULL;
        return symmetricTree(root->left, root->right);
    }
};



4. Inorder Travsersal

// iterative

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> nodes;
        stack<TreeNode*> todo;
        while (root || !todo.empty()) {
            while (root) {
                todo.push(root);
                root = root -> left;
            }
            root = todo.top();
            todo.pop();
            nodes.push_back(root -> val);
            root = root -> right;
        }
        return nodes;
    }
};

// recursive

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> nodes;
        inorder(root, nodes);
        return nodes;
    }
private:
    void inorder(TreeNode* root, vector<int>& nodes) {
        if (!root) {
            return;
        }
        inorder(root -> left, nodes);
        nodes.push_back(root -> val);
        inorder(root -> right, nodes);
    }
};

5. PreOrder

// iterative

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> nodes;
        stack<TreeNode*> todo;
        while (root || !todo.empty()) {
            if (root) {
                nodes.push_back(root -> val);
                if (root -> right) {
                    todo.push(root -> right);
                }
                root = root -> left;
            } else {
                root = todo.top();
                todo.pop();
            }
        }
        return nodes;
    }
};

// Recursive 

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> nodes;
        preorder(root, nodes);
        return nodes;
    }
private:
    void preorder(TreeNode* root, vector<int>& nodes) {
        if (!root) {
            return;
        }
        nodes.push_back(root -> val);
        preorder(root -> left, nodes);
        preorder(root -> right, nodes);
    }
};


6. PostOrder

// Iterative 

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> nodes;
        stack<TreeNode*> todo;
        TreeNode* last = NULL;
        while (root || !todo.empty()) {
            if (root) {
                todo.push(root);
                root = root -> left;
            } else {
                TreeNode* node = todo.top();
                if (node -> right && last != node -> right) {
                    root = node -> right;
                } else {
                    nodes.push_back(node -> val);
                    last = node;
                    todo.pop();
                }
            }
        }
        return nodes;
    }
};

// Recursive 

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> nodes;
        postorder(root, nodes);
        return nodes;
    }
private:
    void postorder(TreeNode* root, vector<int>& nodes) {
        if (!root) {
            return;
        }
        postorder(root -> left, nodes);
        postorder(root -> right, nodes);
        nodes.push_back(root -> val);
    }
};

7. Construct Binary Tree from Preorder and Inorder Traversal

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int idx = 0;
    unordered_map<int,int> ump;
    TreeNode* BuildTree(vector<int>& preorder, vector<int>& inorder, int left, int right){
        if(left>right)
            return NULL;
        
        TreeNode* root = new TreeNode(preorder[idx++]);
        if(left==right)
            return root;
        int mid = ump[root->val];
        root->left = BuildTree(preorder, inorder, left, mid-1);
        root->right = BuildTree(preorder, inorder, mid+1, right);
        
        return root;
        
    } 
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        ump.clear();
        for(int i=0;i<inorder.size();i++)
            ump[inorder[i]]=i;
        return BuildTree(preorder, inorder, 0, inorder.size()-1);
    }
};


8. Construct Binary Tree from Inorder and Postorder Traversal

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    unordered_map<int,int> ump;
    int idx;
    TreeNode* BuildTree(vector<int>& inorder, vector<int>& postorder, int left, int right){
        if(left>right)
            return NULL;
        TreeNode* root = new TreeNode(postorder[idx--]);
        if(left==right)
            return root; 
        int mid = ump[root->val];
        root->right = BuildTree(inorder, postorder, mid+1, right);
        root->left = BuildTree(inorder, postorder, left, mid-1);
        
        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = postorder.size();
        idx = n-1;
        for(int i=0;i<n;i++){
            ump[inorder[i]]=i;
        }
        return BuildTree(inorder, postorder, 0, n-1);
        
    }
};


9. Path Print from Root to leaf 

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<vector<int>> vect;
    vector<int> path;
    void pathPrint(TreeNode* root){
        if(!root)
            return ;
        path.push_back(root->val);
        if(!root->left and !root->right){
            vect.push_back(path);
        }
        pathPrint(root->left);
        pathPrint(root->right);
        path.pop_back();
    }
public:
    int sumNumbers(TreeNode* root) {
        pathPrint(root);
        for(auto x:vect){
            for(auto y:x){
                cout<<y<<" ";
            }
            cout<<endl;
        }
        return 0;
    }
};

11. Merge Two Binary Tree 

class Solution {
    TreeNode* MergeTrees(TreeNode* root1, TreeNode* root2){
        if(root1 and root2){
            TreeNode* root3 = new TreeNode(root1->val + root2->val);
            root3->left = MergeTrees(root1->left, root2->left);
            root3->right = MergeTrees(root1->right, root2->right);
            return root3;
        }
        if(root1){
            return root1;
        }
        return root2;
    }
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        TreeNode* root = MergeTrees(root1, root2);
        return root;
    }
};

12. Find Duplicate subtree

class Solution {
    vector<TreeNode*> ans;
    unordered_map<string,int> ump;
    string subtree(TreeNode* root){
        if(!root)
            return "#";
        string left = subtree(root->left);
        string right = subtree(root->right);
        
        string key = left + " " + right + " " + to_string(root->val); // space given so that numbers were separated.
        
        ump[key]++;
        if(ump[key]==2)
            ans.push_back(root);
        
        return key;
    }
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        subtree(root);
        return ans;
    }
};

13. Vertical order traversal of a binary tree (VVI) *****

class Solution {
    map<int,vector<pair<int,int>> > mp;
    void traversal(TreeNode* root, int row, int col){
        if(!root)
            return ;
        traversal(root->left, row-1, col-1);
        traversal(root->right, row-1, col+1);
        
        mp[col].push_back({-row,root->val});
        
        return ;
    }
    
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        traversal(root, 0, 0);
        vector<vector<int>> res;
        for(auto x:mp){
            vector<pair<int,int>> ans = x.second;
            sort(ans.begin(),ans.end());
            vector<int> final_list;
            for(auto x:ans)
                final_list.push_back(x.second);
            res.push_back(final_list);
        }
        return res;
    }
};




. Diameter of Binary Tree 

TC : O(n^2)

class Solution {
    
    int height(TreeNode* root){
        if(!root)
            return 0;
        int left = height(root->left);
        int right = height(root->right);
        
        return max(left,right)+1;
    }
    
    int diameter(TreeNode* root){
        if(!root)
            return 0;
        
        int left = diameter(root->left);
        int right = diameter(root->right);
        
        int f = height(root->left) + height(root->right) ;
        
        return max(max(left,right),f);
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        
        return diameter(root);
    }
};